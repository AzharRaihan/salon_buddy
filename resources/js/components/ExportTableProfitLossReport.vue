<template>
  <VMenu>
    <template #activator="{ props }">
      <VBtn 
        v-bind="props"
        variant="tonal" 
        color="secondary" 
        prepend-icon="tabler-upload"
        :loading="isExporting"
      >
        Export
        <VIcon icon="tabler-chevron-down" class="ml-1" />
      </VBtn>
    </template>

    <VList>
      <VListItem
        prepend-icon="tabler-file-type-pdf"
        title="Export as PDF"
        @click="exportToPDF"
      />
      <VListItem
        prepend-icon="tabler-file-type-csv"
        title="Export as CSV"
        @click="exportToCSV"
      />
      <VListItem
        prepend-icon="tabler-file-spreadsheet"
        title="Export as Excel"
        @click="exportToExcel"
      />
    </VList>
  </VMenu>
</template>

<script setup>
import { ref } from 'vue'
import { toast } from 'vue3-toastify'
import jsPDF from 'jspdf'
import autoTable from 'jspdf-autotable'

const props = defineProps({
  reportData: {
    type: Object,
    required: true,
    default: () => ({})
  },
  filename: {
    type: String,
    default: 'profit-loss-report'
  },
  title: {
    type: String,
    default: 'Profit & Loss Report'
  },
  headerData: {
    type: Object,
    default: () => ({
      reportTitle: 'Profit & Loss Report',
      outletName: 'All Outlets',
      phone: null,
      address: null,
      dateRange: 'All Time',
      generatedOn: '',
      generatedBy: 'N/A',
      costingMethod: 'Last Purchase Price'
    })
  }
})

const isExporting = ref(false)

// Helper function to format data for export
const formatDataForExport = () => {
  const data = [
    { label: 'Total Sales (Paid & Unpaid)', value: props.reportData.total_sales || 0 },
    { label: 'Total Cost of Sale', value: props.reportData.total_cost_of_sale || 0 },
    { label: 'Tax', value: props.reportData.tax || 0 },
    { label: 'Discount', value: props.reportData.discount || 0 },
    { label: 'Tips', value: props.reportData.total_tips || 0 },
    { label: 'Delivery Charge', value: props.reportData.delivery_charge || 0 },
    { label: 'Gross Profit', value: props.reportData.gross_profit || 0, isTotal: true },
    { label: 'Total Salaries', value: props.reportData.total_salaries || 0 },
    { label: 'Expense', value: props.reportData.expense || 0 },
    { label: 'Net Profit', value: props.reportData.net_profit || 0, isTotal: true }
  ]

  return data
}

// Export to CSV
const exportToCSV = () => {
  try {
    isExporting.value = true
    const data = formatDataForExport()

    // Create header info rows
    const headerInfo = [
      props.headerData.reportTitle,
      '',
      `Outlet: ${props.headerData.outletName}`
    ]
    
    // Add phone and address only if they exist (specific branch selected)
    if (props.headerData.phone) {
      headerInfo.push(`Phone: ${props.headerData.phone}`)
    }
    if (props.headerData.address) {
      headerInfo.push(`Address: ${props.headerData.address}`)
    }
    
    headerInfo.push(
      `Date Range: ${props.headerData.dateRange}`,
      `Generated On: ${props.headerData.generatedOn}`,
      `Generated By: ${props.headerData.generatedBy}`,
      `Costing Method: ${props.headerData.costingMethod}`,
      '',
      ''
    )

    const csvContent = [
      ...headerInfo,
      'Item,Amount',
      ...data.map(item => {
        const value = item.value || 0
        return `"${item.label}","${value}"`
      })
    ].join('\n')
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' })
    const link = document.createElement('a')
    const url = URL.createObjectURL(blob)
    link.setAttribute('href', url)
    link.setAttribute('download', `${props.filename}.csv`)
    link.style.visibility = 'hidden'
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
    
    toast('CSV exported successfully', { type: 'success' })
  } catch (error) {
    console.error('Error exporting CSV:', error)
    toast('Failed to export CSV', { type: 'error' })
  } finally {
    isExporting.value = false
  }
}

// Export to Excel
const exportToExcel = async () => {
  try {
    isExporting.value = true
    
    // Dynamic import to avoid bundling if not used
    const XLSX = await import('xlsx')
    const data = formatDataForExport()
    
    // Create header info rows
    const headerInfo = [
      [props.headerData.reportTitle],
      [],
      ['Outlet:', props.headerData.outletName]
    ]
    
    // Add phone and address only if they exist (specific branch selected)
    if (props.headerData.phone) {
      headerInfo.push(['Phone:', props.headerData.phone])
    }
    if (props.headerData.address) {
      headerInfo.push(['Address:', props.headerData.address])
    }
    
    headerInfo.push(
      ['Date Range:', props.headerData.dateRange],
      ['Generated On:', props.headerData.generatedOn],
      ['Generated By:', props.headerData.generatedBy],
      ['Costing Method:', props.headerData.costingMethod],
      []
    )
    
    // Create worksheet with header info
    const ws = XLSX.utils.aoa_to_sheet(headerInfo)
    
    // Add table headers and data
    const tableData = [
      ['Item', 'Amount'],
      ...data.map(item => [item.label, item.value || 0])
    ]
    
    XLSX.utils.sheet_add_aoa(ws, tableData, { 
      origin: `A${headerInfo.length + 1}`
    })
    
    // Create workbook
    const wb = XLSX.utils.book_new()
    XLSX.utils.book_append_sheet(wb, ws, 'Sheet1')
    
    // Save file
    XLSX.writeFile(wb, `${props.filename}.xlsx`)
    
    toast('Excel file exported successfully', { type: 'success' })
  } catch (error) {
    console.error('Error exporting Excel:', error)
    toast('Failed to export Excel file. Please install xlsx package.', { type: 'error' })
  } finally {
    isExporting.value = false
  }
}

// Export to PDF
const exportToPDF = () => {
  try {
    isExporting.value = true
    const data = formatDataForExport()
    const doc = new jsPDF()
    const pageWidth = doc.internal.pageSize.getWidth()
    
    let currentY = 15
    
    // Report Title
    doc.setFontSize(16)
    doc.setFont(undefined, 'bold')
    doc.text(props.headerData.reportTitle, pageWidth / 2, 15, { align: 'center' })
    currentY += 10
    
    // Outlet Info (Left Side)
    doc.setFontSize(10)
    doc.setFont(undefined, 'normal')
    doc.text(`Outlet: ${props.headerData.outletName}`, 14, currentY)
    
    // Track the right side Y position
    const rightStartY = currentY
    currentY += 6
    
    // Add phone and address only if they exist (specific branch selected)
    if (props.headerData.phone) {
      doc.text(`Phone: ${props.headerData.phone}`, 14, currentY)
      currentY += 6
    }
    if (props.headerData.address) {
      doc.text(`Address: ${props.headerData.address}`, 14, currentY)
      currentY += 6
    }
    
    // Generated Info (Right Side)
    doc.text(`Date Range: ${props.headerData.dateRange}`, pageWidth - 14, rightStartY, { align: 'right' })
    doc.text(`Generated On: ${props.headerData.generatedOn}`, pageWidth - 14, rightStartY + 6, { align: 'right' })
    doc.text(`Generated By: ${props.headerData.generatedBy}`, pageWidth - 14, rightStartY + 12, { align: 'right' })
    doc.text(`Costing Method: ${props.headerData.costingMethod}`, pageWidth - 14, rightStartY + 18, { align: 'right' })
    
    // Calculate the maximum Y position from both left and right sides
    const rightEndY = rightStartY + 18
    const maxY = Math.max(currentY, rightEndY)
    
    // Add spacing before table (ensure there's enough gap)
    currentY = maxY + 10
    
    // Add table
    autoTable(doc, {
      head: [['Item', 'Amount']],
      body: data.map(item => [item.label, item.value || 0]),
      startY: currentY,
      styles: {
        fontSize: 8,
        cellPadding: 2
      },
      headStyles: {
        fillColor: [66, 139, 202],
        textColor: 255,
        fontStyle: 'bold'
      },
      didParseCell: function (data) {
        // Style total rows
        const rowIndex = data.row.index
        if (data.row.raw && data.row.raw.isTotal) {
          data.cell.styles.fillColor = [200, 230, 255]
          data.cell.styles.fontStyle = 'bold'
        }
      }
    })

    doc.save(`${props.filename}.pdf`)
    toast('PDF exported successfully', { type: 'success' })
  } catch (error) {
    console.error('Error exporting PDF:', error)
    toast('Failed to export PDF. Please install jspdf and jspdf-autotable packages.', { type: 'error' })
  } finally {
    isExporting.value = false
  }
}
</script>

